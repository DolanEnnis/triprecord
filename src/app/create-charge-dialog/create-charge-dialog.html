<h1 mat-dialog-title>{{ title }}</h1>

<div mat-dialog-content [formGroup]="form">
  <div class="form-grid">
    <mat-form-field>
      <mat-label>Ship</mat-label>
      <input matInput formControlName="ship" [matAutocomplete]="autoShip" required>
      <mat-autocomplete #autoShip="matAutocomplete" [displayWith]="displayShip" (optionSelected)="onShipSelected($event)">
        @for (ship of filteredShips$ | async; track ship.ship) {
          <mat-option [value]="ship">{{ ship.ship }}</mat-option>
        }
      </mat-autocomplete>
    </mat-form-field>

    <mat-form-field>
      <mat-label>GT</mat-label>
      <input matInput type="number" formControlName="gt">
    </mat-form-field>

    <mat-form-field>
      <mat-label>Boarding Date</mat-label>
      <input matInput [matDatepicker]="picker" formControlName="boarding" [max]="maxDate">
      <mat-datepicker-toggle matIconSuffix [for]="picker"></mat-datepicker-toggle>
      <mat-datepicker #picker></mat-datepicker>
    </mat-form-field>

    <mat-form-field>
      <mat-label>To/From</mat-label>
      <mat-select formControlName="port">
        @for (port of ports; track port) {
          <mat-option [value]="port">{{ port }}</mat-option>
        }
      </mat-select>
    </mat-form-field>

    <mat-form-field>
      <mat-label>Pilot</mat-label>
      <input 
        matInput 
        formControlName="pilot"
        [matAutocomplete]="pilotAuto"
        (input)="onPilotInput($any($event.target).value)">
      <mat-autocomplete #pilotAuto="matAutocomplete">
        @for (pilot of filteredPilots(); track pilot) {
          <mat-option [value]="pilot === 'Unassigned' ? '' : pilot">
            {{ pilot }}
          </mat-option>
        }
      </mat-autocomplete>
      @if (form.get('pilot')?.hasError('invalidPilot')) {
        <mat-error>
          Please select a valid pilot from the list
        </mat-error>
      }
    </mat-form-field>

    <mat-form-field>
      <mat-label>Type</mat-label>
      <mat-select formControlName="typeTrip">
        @for (type of tripTypes; track type) {
          <mat-option [value]="type">{{ type }}</mat-option>
        }
      </mat-select>
    </mat-form-field>

    <mat-form-field class="full-width">
      <mat-label>Extras (Late Order / Detention etc)</mat-label>
      <textarea matInput formControlName="extra"></textarea>
    </mat-form-field>

    <mat-form-field class="full-width">
      <mat-label>Note</mat-label>
      <textarea matInput formControlName="sailingNote"></textarea>
    </mat-form-field>
  </div>

  <!-- PILOT'S OWN INFO SECTION -->
  <div class="pilot-own-section">
    <h3 class="pilot-section-title">Pilot's Own Info</h3>
    <div class="pilot-four-col-grid">
      <!-- Pilot No -->
      <mat-form-field appearance="outline">
        <mat-label>Pilot No</mat-label>
        <input matInput type="number" formControlName="pilotNo" placeholder="No.">
      </mat-form-field>

      <!-- Month No -->
      <mat-form-field appearance="outline">
        <mat-label>Month No</mat-label>
        <input matInput type="number" formControlName="monthNo" placeholder="Month">
      </mat-form-field>

      <!-- Good (Rating) -->
      <mat-form-field appearance="outline">
        <mat-label>Good</mat-label>
        <input matInput type="number" formControlName="good" placeholder="1-5">
      </mat-form-field>

      <!-- Car -->
      <mat-form-field appearance="outline">
        <mat-label>Car</mat-label>
        <input matInput formControlName="car" placeholder="Vehicle">
      </mat-form-field>
    </div>
  </div>


  <!-- Docket Upload: shown in fromVisit and editCharge modes only.
       In 'new' mode there is no tripId yet (it's created on save), so
       the pilot can attach a docket after confirmation from the edit-trip page. -->
  @if (mode !== 'new' && docketTripId) {
    <div class="docket-section">
      <p class="docket-label">
        <mat-icon class="docket-label-icon">attach_file</mat-icon>
        Docket
      </p>

      <!-- LEARNING: PARENT-CHILD WIRING
           The parent (this dialog) listens for two output events:
           - (docketUploaded): fires when a file is fully uploaded → stores URL/path/type
           - (uploadingChange): fires while upload is in progress → disables Save button
           This guarantees the Firestore write ONLY happens AFTER the Storage upload completes. -->
      <app-docket-upload
        [tripId]="docketTripId"
        [existingDocketUrl]="chargeToEdit?.docketUrl"
        [existingDocketPath]="chargeToEdit?.docketPath"
        [existingDocketType]="chargeToEdit?.docketType"
        (docketUploaded)="onDocketUploaded($event)"
        (uploadingChange)="onDocketUploadingChange($event)"
      ></app-docket-upload>
    </div>
  }
</div>

<div mat-dialog-actions align="end">
  @if (mode === 'editCharge' && chargeToEdit?.visitId) {
    <button mat-stroked-button color="warn" (click)="onEditVisit()" [disabled]="isSaving" style="margin-right: auto;">
      <mat-icon>edit</mat-icon> Edit Trip/Visit
    </button>
  }
  <button mat-button (click)="onCancel()" [disabled]="isSaving">Cancel</button>
  
  <!-- 
    Tooltip wrapper for disabled button pattern
    - Disabled buttons don't receive mouse events
    - Wrapper receives hover and displays tooltip
    - Dynamic tooltip shows validation errors, save status, or upload-in-progress message
  -->
  <div [matTooltip]="getSaveButtonTooltip()" class="save-button-wrapper">
    <button mat-flat-button color="primary" (click)="onSave()" [disabled]="form.invalid || isSaving || isDocketUploading">
      @if (isSaving) {
        <mat-progress-spinner mode="indeterminate" diameter="20"></mat-progress-spinner>
      } @else {
        <span>Save Charge</span>
      }
    </button>
  </div>
</div>
